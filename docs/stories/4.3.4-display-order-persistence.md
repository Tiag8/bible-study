# Story 4.3.4: Persist√™ncia de Ordem de Refer√™ncias

**Epic**: 4.3 - Refer√™ncias Bidirecionais & Links Externos com Coloriza√ß√£o
**Status**: üü° Ready for Development
**Priority**: üü° ALTA
**Story Points**: 2
**Assignee**: @dev
**Arch Review**: @architect (Aria - Approving)

---

## üìñ USER STORY

**Como** um estudioso b√≠blico
**Quero** reordenar minhas refer√™ncias por import√¢ncia/contexto
**Para** que a ordem seja salva e restaurada quando eu voltar

### Why This Matters
- üìä **Organiza√ß√£o**: Permite priorizar referencias por relev√¢ncia
- üíæ **Persist√™ncia**: Ordem customizada √© salva permanentemente
- ‚ö° **Efici√™ncia**: R√°pido acessar r√©f√©rences mais importantes

---

## ‚úÖ CRIT√âRIOS DE ACEITA√á√ÉO

### A. Reordenar Refer√™ncias via Drag-and-Drop

```gherkin
Scenario: Arrastar refer√™ncia para cima
  Given tenho 3 refer√™ncias: [A, B, C]
  And B est√° em posi√ß√£o 2
  When clico e arrasto B para posi√ß√£o 1
  Then vejo anima√ß√£o suave
  And ordem local muda: [B, A, C]
  And toast: "Ordem salva"

Scenario: Arrastar para baixo
  Given ordem √© [A, B, C]
  And A est√° em posi√ß√£o 1
  When clico e arrasto A para posi√ß√£o 3
  Then ordem muda: [B, C, A]
  And BD atualiza `display_order`

Scenario: Ordem persiste ap√≥s reload
  Given reorderei referencias em [B, A, C]
  When recarrego p√°gina
  Then ordem restaurada √© [B, A, C]
  And n√£o volta para [A, B, C]
```

**Valida√ß√µes T√©cnicas**:
- [ ] Cada refer√™ncia tem `display_order` campo (0, 1, 2, ...)
- [ ] Reorder atualiza `display_order` em DB
- [ ] Refetch carrega com ordem correta
- [ ] N√£o h√° gaps (ex: [0, 2, 5] √© inv√°lido)

---

### B. Valida√ß√£o de Ordem

```gherkin
Scenario: Ordem √© cont√≠gua (sem gaps)
  Given reordeno items
  When salvo no DB
  Then sequ√™ncia √© [0, 1, 2, 3, ...]
  And n√£o h√° [0, 2, 4] (gaps)

Scenario: Insert nova refer√™ncia
  Given tenho [A(0), B(1), C(2)]
  When adiciono D
  Then D recebe display_order = 3
  And ordem fica [A(0), B(1), C(2), D(3)]
```

**Valida√ß√µes T√©cnicas**:
- [ ] `display_order >= 0` e cont√≠guo
- [ ] Insert novo item: `display_order = MAX() + 1`
- [ ] Migration seta defaults em linhas existentes

---

### C. Performance

```gherkin
Scenario: Reorder √© r√°pido
  Given tenho 20 refer√™ncias
  When reordeno 1
  Then salva em < 100ms
  And toast aparece imediatamente
  And sem lag visual
```

**Valida√ß√µes T√©cnicas**:
- [ ] Query r√°pida (√≠ndice em source_study_id)
- [ ] Sem N+1 queries
- [ ] Toast otimista (n√£o aguarda resposta)

---

## üõ†Ô∏è TASKS T√âCNICAS

### Database (Backend)

- [ ] **Migration**: Adicionar coluna `display_order` (j√° em 4.3.1, validar)
  ```sql
  ALTER TABLE bible_study_links ADD COLUMN (
    display_order SMALLINT DEFAULT 0
  );

  -- Backfill com valores sequenciais
  WITH ordered_refs AS (
    SELECT id, ROW_NUMBER() OVER (
      PARTITION BY source_study_id ORDER BY created_at
    ) - 1 AS new_order
    FROM bible_study_links
  )
  UPDATE bible_study_links
  SET display_order = ordered_refs.new_order
  FROM ordered_refs
  WHERE bible_study_links.id = ordered_refs.id;

  -- √çndice para performance
  CREATE INDEX idx_bible_study_links_display_order
  ON bible_study_links(source_study_id, display_order);
  ```

- [ ] **Valida√ß√£o**: Trigger ou CHECK (opcional para MVP)
  ```sql
  -- Opcional: Prevenir gaps em insert
  CREATE OR REPLACE FUNCTION validate_display_order()
  RETURNS TRIGGER AS $$
  BEGIN
    -- Valida que display_order >= 0
    IF NEW.display_order < 0 THEN
      RAISE EXCEPTION 'display_order must be >= 0';
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  ```

---

### Backend/Hook (`useReferences.ts`)

- [ ] **Atualizar `reorderReference()`**
  ```typescript
  export interface ReorderPayload {
    referenceId: string;
    direction: 'up' | 'down';
  }

  async function reorderReference(
    referenceId: string,
    direction: 'up' | 'down'
  ): Promise<boolean> {
    // 1. Encontra refer√™ncia atual
    const currentRef = references.find(r => r.id === referenceId);
    if (!currentRef) throw new Error('Refer√™ncia n√£o encontrada');

    // 2. Encontra vizinho (para cima ou para baixo)
    const currentIndex = references.findIndex(r => r.id === referenceId);
    const neighborIndex = direction === 'up'
      ? currentIndex - 1
      : currentIndex + 1;

    if (neighborIndex < 0 || neighborIndex >= references.length) {
      return false;  // Already at boundary
    }

    const neighbor = references[neighborIndex];

    // 3. Swap display_order no DB
    const { error } = await supabase.rpc('swap_display_order', {
      ref_id_1: referenceId,
      ref_id_2: neighbor.id
    });

    if (error) throw error;

    // 4. Atualizar local state (otimista)
    const newRefs = [...references];
    [newRefs[currentIndex], newRefs[neighborIndex]] =
      [newRefs[neighborIndex], newRefs[currentIndex]];
    setReferences(newRefs);

    // 5. Refetch para garantir sincroniza√ß√£o
    await refetch();

    return true;
  }
  ```

- [ ] **RPC Helper: `swap_display_order()`**
  ```sql
  CREATE OR REPLACE FUNCTION swap_display_order(
    ref_id_1 UUID,
    ref_id_2 UUID
  )
  RETURNS void AS $$
  DECLARE
    order_1 SMALLINT;
    order_2 SMALLINT;
  BEGIN
    -- Encontra os display_order
    SELECT display_order INTO order_1
    FROM bible_study_links WHERE id = ref_id_1;

    SELECT display_order INTO order_2
    FROM bible_study_links WHERE id = ref_id_2;

    -- Swap atomicamente
    UPDATE bible_study_links SET display_order = order_2
    WHERE id = ref_id_1;

    UPDATE bible_study_links SET display_order = order_1
    WHERE id = ref_id_2;
  END;
  $$ LANGUAGE plpgsql;
  ```

---

### Frontend/Hook Integration

- [ ] **Refetch carrega com ordem correta**
  ```typescript
  // useReferences.ts - fetchReferences()
  async function fetchReferences() {
    const { data, error } = await supabase
      .from('bible_study_links')
      .select('*')
      .eq('user_id', user?.id)
      .eq('source_study_id', studyId)
      .order('display_order', { ascending: true })  // ‚Üê KEY
      .order('created_at', { ascending: true });    // ‚Üê fallback

    if (error) throw error;

    // ... enrich com target data

    setReferences(data || []);
  }
  ```

---

### Frontend/Component (`ReferencesSidebar.tsx`)

- [ ] **Toast otimista de reorder**
  ```typescript
  const handleReorder = async (refId: string, direction: 'up' | 'down') => {
    // Otimista: mostrar resultado antes de salvar
    const success = await reorderReference(refId, direction);

    if (success) {
      toast.success('Ordem salva');
    } else {
      toast.info('J√° est√° no topo/fim');
    }
  };
  ```

---

### Frontend/Component (`DndContext` - J√° Existe)

- [ ] **Validar que `@dnd-kit` persiste ordem**
  ```typescript
  // SortableContext j√° renderiza com ordem do array
  // Se array tiver display_order sequencial, drag-drop funciona
  // Importante: refetch ap√≥s drag para garantir sincroniza√ß√£o
  ```

---

## üìä ESTIMATIVA DE PONTOS

| Task | Horas | Pontos |
|------|-------|--------|
| Migration + backfill | 0.5h | 1 |
| RPC helper (swap_display_order) | 0.5h | 1 |
| Hook updates + refetch | 0.5h | - |
| Component toast integration | 0.25h | - |
| Testing (manual + E2E) | 0.25h | - |
| **Total** | **2h** | **2 pontos** |

---

## üß™ TESTE CHECKLIST

### Testes Manuais (Browser)

- [ ] **Reorder b√°sico**
  - [ ] Clica up em item meio (move para cima)
  - [ ] Toast: "Ordem salva"
  - [ ] Item move visualmente

- [ ] **Boundary conditions**
  - [ ] Clica up em item topo ‚Üí nada muda
  - [ ] Clica down em item fim ‚Üí nada muda
  - [ ] Toast: "J√° est√° no topo/fim"

- [ ] **Persist√™ncia**
  - [ ] Reordena: [A, B, C] ‚Üí [C, A, B]
  - [ ] Recarrega p√°gina
  - [ ] Ordem restaura: [C, A, B]

- [ ] **Com drag-and-drop**
  - [ ] Arrasta item
  - [ ] Display order atualiza no DB
  - [ ] Refetch carrega com ordem correta

### Testes Automatizados (E2E)

```typescript
// tests/references-display-order.spec.ts
test('reorder com up button', async ({ page }) => {
  // 1. Create 3 references
  // 2. Click up on item 2
  // 3. Verify order changes in UI
  // 4. Reload
  // 5. Verify order persisted
});

test('reorder com drag-drop', async ({ page }) => {
  // 1. Create 3 references
  // 2. Drag item 1 to position 3
  // 3. Verify display_order updated in DB
  // 4. Reload
  // 5. Verify order persisted
});

test('boundary conditions', async ({ page }) => {
  // 1. Try to move top item up ‚Üí no change
  // 2. Try to move bottom item down ‚Üí no change
});
```

### SQL Tests

```sql
-- Verify display_order increments
SELECT display_order FROM bible_study_links
WHERE source_study_id = 'test-id'
ORDER BY display_order;
-- Expected: 0, 1, 2, 3, ... (sem gaps)

-- Verify RPC swap funciona
CALL swap_display_order('ref_id_1', 'ref_id_2');
SELECT id, display_order FROM bible_study_links
WHERE id IN ('ref_id_1', 'ref_id_2');
-- Expected: orders trocadas
```

---

## üîç QUALITY GATES

### CodeRabbit Integration

**When**: After creating PR

**Focus Areas**:
- [ ] **Performance**: √çndice em `(source_study_id, display_order)`?
- [ ] **Atomicity**: Swap √© transacional? Sem race conditions?
- [ ] **UX**: Toast timing correto? N√£o fica preso?
- [ ] **Tests**: E2E covers reorder + persist?

**Expected Issues**:
- üü¢ LOW: Toast optimization (otimista vs real)

---

## üìã ACCEPTANCE CHECKLIST (Para QA/PM)

- [ ] Reorder com up/down buttons funciona
- [ ] Ordem persiste ap√≥s reload
- [ ] Boundary conditions (topo/fim) funcionam
- [ ] Drag-and-drop atualiza DB
- [ ] Toast aparece ap√≥s reorder
- [ ] Sem gaps em display_order (0, 1, 2, ...)
- [ ] Performance: < 100ms
- [ ] Nenhum console error

---

## üöÄ HANDOFF PARA @DEV

### Pre-requisites
1. ‚úÖ Stories 4.3.1, 4.3.2, 4.3.3 merge completo
2. ‚úÖ `display_order` coluna existe (via 4.3.1 migration)
3. ‚úÖ Branch: `feature/4.3.4-display-order`

### Implementa√ß√£o (Para @dev)
1. **Fase 1**: Migration + RPC (0.5h)
2. **Fase 2**: Hook updates (0.5h)
3. **Fase 3**: Toast integration (0.25h)
4. **Fase 4**: Testing (0.75h)

### Defini√ß√£o de Done
- [ ] PR criada com tests
- [ ] Migration backfill sucesso
- [ ] RPC swap funciona
- [ ] E2E reorder test pasando
- [ ] Pronto para merge

---

## üîó DEPEND√äNCIAS

### Blockers
- üî¥ Story 4.3.1 (schema + migration base)

### Dependents
- Nenhuma (√∫ltimo da s√©rie)

---

## üìö REFER√äNCIAS

- **Epic**: `/docs/stories/EPIC-4.3-enhanced-references.md`
- **Schema**: `display_order SMALLINT` (criado em 4.3.1)
- **Padr√£o**: dnd-kit j√° gerencia reordena√ß√£o UI
- **SQL Pattern**: Row-number backfill do `~/.claude/memory/`

---

## üìù NOTES

- `display_order` √© SMALLINT (0-32767, suficiente para refs)
- Backfill √© cr√≠tica (ordena por `created_at` se display_order vazio)
- RPC swap √© simples (2 UPDATEs na mesma transa√ß√£o)
- Refetch garante sincroniza√ß√£o (n√£o confiar apenas em otimista)
- √çndice em `(source_study_id, display_order)` √© essencial

---

**Criada por**: River (Scrum Master) üåä
**Para implementa√ß√£o por**: @dev
**Data**: 2026-01-28
**Vers√£o**: 1.0 (Ready for Development)
