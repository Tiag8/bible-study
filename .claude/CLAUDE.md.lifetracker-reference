# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

---

# Life Track Growth - AI Habit Tracker

> Aplica√ß√£o AI-powered de desenvolvimento pessoal baseada na metodologia "Roda da Vida" (8 √°reas fixas).

**Stack**: React 18.3 + TypeScript 5.8 + Vite 5.4 + Supabase + Gemini AI 2.5 Flash

---

## üìö ESTRUTURA DE DOCUMENTA√á√ÉO

**Hierarquia**: Este arquivo > `/Users/tiago/.codeium/windsurf/memories/global_rules.md`

**Documenta√ß√£o detalhada**: Ver `docs/` para arquitetura completa, features, workflows, etc.

---

## üõ†Ô∏è COMANDOS ESSENCIAIS

```bash
# Development
npm run dev                   # http://localhost:8080
npm run build && npm run preview

# Quality Gates (PRE-COMMIT)
./scripts/run-tests.sh                 # TypeScript + ESLint + Build
./scripts/code-review.sh               # Auto review
./scripts/run-security-tests.sh        # Security scan

# Database
supabase migration new <name>
supabase db push
./scripts/regenerate-supabase-types.sh  # Ap√≥s schema changes

# Deploy
./scripts/deploy-vps.sh production     # VPS Docker Swarm
./scripts/vps-rollback.sh production   # Rollback (2-3min)

# Validation (listar todos)
ls scripts/validate-*.sh        # 10+ validation scripts dispon√≠veis
ls scripts/*.sh | grep -E "(test|validate|check)"  # Scripts qualidade
```

---

## üèóÔ∏è ARQUITETURA

### Estrutura de Diret√≥rios

```
life_tracker/
‚îú‚îÄ‚îÄ .claude/agents/         # 12 subagents especializados
‚îú‚îÄ‚îÄ .windsurf/workflows/    # 34 workflows modulares
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/         # Feature-first (assessment/, coach/, habits/)
‚îÇ   ‚îú‚îÄ‚îÄ hooks/              # Custom hooks (useDashboardData, etc)
‚îÇ   ‚îú‚îÄ‚îÄ integrations/       # Supabase client + types
‚îÇ   ‚îî‚îÄ‚îÄ lib/                # Utils (dateUtils, cardUtils)
‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îú‚îÄ‚îÄ functions/          # 10 Edge Functions (Deno)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ _shared/        # 46 utilities (auth, security, RAG, etc)
‚îÇ   ‚îî‚îÄ‚îÄ migrations/         # 41 SQL migrations
‚îú‚îÄ‚îÄ docs/                   # 152+ docs (ADRs, debugging, ops)
‚îî‚îÄ‚îÄ scripts/                # 40+ automation scripts
```

### Padr√µes Cr√≠ticos

**1. Feature-First Components**
```typescript
src/components/
‚îú‚îÄ‚îÄ assessment/  # Tudo de assessments aqui
‚îú‚îÄ‚îÄ coach/       # Tudo de AI Coach aqui
‚îú‚îÄ‚îÄ habits/      # Tudo de habits aqui
‚îî‚îÄ‚îÄ ui/          # shadcn/ui shared
```

**2. Custom Hooks (L√≥gica Isolada)**
```typescript
// Parallel queries - NUNCA sequencial
const useDashboardData = () => {
  const { data: profile } = useQuery({...});
  const { data: habits } = useQuery({...});
  const { data: goals } = useQuery({...});
  return { profile, habits, goals };
};
```

**3. Webhook + RLS Pattern**
```typescript
// Edge Functions: Service Role bypass RLS inicial
const supabase = createClient(url, SERVICE_ROLE_KEY); // Bypass RLS
const userId = await getOrCreateUser(phone);
await supabase.from('lifetracker_profiles').insert({ user_id: userId, ... });
// Frontend: RLS aplica automaticamente
```

**4. FSM WhatsApp Onboarding**
```typescript
// 9 estados sequenciais em JSONB metadata
{ "whatsapp_state": "category_selected", "onboarding_step": 4 }
switch (state) {
  case 'lgpd_consent': return handleConsent();
  case 'email_collected': return handleEmail();
}
```

---

## ‚ö†Ô∏è REGRAS ABSOLUTAS

**√çndice de Regras** (12 regras cr√≠ticas):
1. Uso M√°ximo de Agentes (paraleliza√ß√£o)
2. Nunca Parar Desnecessariamente (80-90% contexto)
3. Reframing Antes de RCA (problema CERTO)
4. Root Cause Analysis - RCA (5 Whys ‚Üí causa raiz)
4B. Resolu√ß√£o em Teia (mapear TODA teia conectada)
5. Advogado do Diabo (10 perguntas valida√ß√£o)
6. Nunca Calcular ROI/Tempo (proibido para IA)
7. Preven√ß√£o de Regress√£o (c√≥digo funcionando √© SAGRADO)
8. Source of Truth Validation (DB real > c√≥digo)
9. Princ√≠pio Pareto 80/20 (20% entrega 80% valor)
10. Anti-Over-Engineering (YAGNI + KISS)
11. Evid√™ncias Obrigat√≥rias (NUNCA achismos)

---

### üö® 1. USO M√ÅXIMO DE AGENTES (MAIS IMPORTANTE)

**SEMPRE** usar **M√ÅXIMO de agentes poss√≠vel em paralelo**.

**SEMPRE** verificar quais agentes da pasta @claude/agents fazem sentido para a tarefa atual.

**Quando usar m√∫ltiplos agentes**:
- Tarefas independentes execut√°veis simultaneamente
- Explora√ß√£o c√≥digo + an√°lise deps + verifica√ß√£o configs
- Testes em diferentes m√≥dulos

**Benef√≠cio**: Paraleliza√ß√£o massiva de tarefas

---

### üö® 2. NUNCA PARAR DESNECESSARIAMENTE

**PARE APENAS** quando: tokens < 20% E tarefa complexa OR erro cr√≠tico OR usu√°rio pediu

**N√ÉO PARE para**:
- ‚ùå Criar docs intermedi√°rias
- ‚ùå "Organizar" c√≥digo funcionando
- ‚ùå Pausas preventivas

**Target**: Usar 80-90% contexto (160k-180k tokens)

**C√°lculo**:
```
Tokens estimados = linhas_c√≥digo * 4 + contexto * 2
SE tokens_restantes > estimados * 1.5: CONTINUAR
```

---

### üö® 3. REFRAMING ANTES DE RCA

**Ordem cr√≠tica**:
1. **Reframing** ‚Üí Problema CERTO
2. **RCA (5 Whys)** ‚Üí Causa raiz
3. **Resolu√ß√£o em Teia** ‚Üí Mapear tudo conectado
4. **Solu√ß√£o** ‚Üí Fix + preven√ß√£o

**Pergunta forte**: "Qual problema, se resolvido, eliminaria m√∫ltiplos problemas?"

**Checklist**:
- [ ] Questionei problema apresentado?
- [ ] Busquei 2+ perspectivas externas?
- [ ] Apliquei pergunta forte?
- [ ] Novo framing abre solu√ß√µes invis√≠veis?

---

### üö® 4. ROOT CAUSE ANALYSIS (5 Whys)

**SEMPRE** executar 5 Whys ANTES de corre√ß√µes.

**Exemplo**:
1. Por qu√™ X falhou? ‚Üí Y retornou NULL
2. Por qu√™ NULL? ‚Üí Coluna n√£o existe
3. Por qu√™ n√£o existe? ‚Üí Migration n√£o criou
4. Por qu√™ n√£o criou? ‚Üí C√≥digo antes de migration
5. Por qu√™ antes? ‚Üí Faltou checklist Schema-First

**Causa Raiz**: Falta de checklist pre-implementation

**Regra**: Se solu√ß√£o n√£o previne recorr√™ncia, N√ÉO √© solu√ß√£o - √© band-aid.

**Documentar**:
- ADR (decis√£o arquitetural)
- Debugging Case (`docs/debugging-cases/`)
- Meta-Learning (lesson learned)

---

### üö® 4B. RESOLU√á√ÉO EM TEIA (Web Resolution)

**CR√çTICO**: Ap√≥s identificar a causa raiz (RCA), SEMPRE mapear e resolver TODA a teia de problemas conectados.

**Quando usar**: DEPOIS do RCA, ANTES de implementar solu√ß√£o final.

**Objetivo**: Garantir solu√ß√£o completa que previne m√∫ltiplos problemas relacionados, n√£o apenas o sintoma inicial.

**Metodologia**:

**1. Mapeamento da Teia** (An√°lise 360¬∞):
- **Frontend**: Componentes, hooks, context, state management
- **Backend**: Edge Functions, APIs, valida√ß√µes, business logic
- **Database**: Schema, RLS policies, migrations, triggers, functions
- **Integra√ß√µes**: APIs externas, webhooks, eventos
- **Documenta√ß√£o**: ADRs, debugging cases, workflows, README
- **Testes**: Unit, integration, E2E, valida√ß√µes
- **Configs**: Environment vars, build configs, deploy

**2. Identifica√ß√£o de Conex√µes**:
- Quais arquivos IMPORTAM/EXPORTAM c√≥digo relacionado?
- Quais fun√ß√µes CHAMAM/S√ÉO CHAMADAS pela √°rea afetada?
- Quais tabelas t√™m FOREIGN KEYS ou JOINS relacionados?
- Quais componentes CONSOMEM os dados afetados?
- Quais docs REFERENCIAM o problema ou √°rea?

**3. An√°lise de Impacto**:
- [ ] Mudan√ßa na causa raiz afeta outras features?
- [ ] Existem padr√µes similares com mesmo problema?
- [ ] Outros lugares usam mesma l√≥gica problem√°tica?
- [ ] Documenta√ß√£o precisa ser atualizada?
- [ ] Testes existentes cobrem casos relacionados?

**4. Resolu√ß√£o Hol√≠stica**:
- ‚úÖ Corrigir causa raiz (RCA)
- ‚úÖ Corrigir padr√µes similares (preven√ß√£o)
- ‚úÖ Atualizar documenta√ß√£o relacionada
- ‚úÖ Adicionar testes para casos conectados
- ‚úÖ Validar n√£o introduziu regress√µes

**Exemplo Pr√°tico (Bug Parsing WhatsApp)**:

**RCA identificou**: Formato de bot√£o UAZAPI mudou (`selectedID` ‚Üí `selectedId`)

**Resolu√ß√£o em Teia MAPEIA**:

**Frontend**:
- [ ] Componentes que exibem mensagens WhatsApp
- [ ] Hooks que processam hist√≥rico de mensagens
- [ ] Types/interfaces de mensagens WhatsApp

**Backend**:
- [ ] ‚úÖ `webhook-whatsapp-natural/index.ts` (causa raiz)
- [ ] `webhook-whatsapp-adapter/index.ts` (usa mesmo parsing?)
- [ ] `_shared/habit-field-extractor.ts` (processa bot√µes?)
- [ ] Outras Edge Functions que recebem webhooks UAZAPI

**Database**:
- [ ] Tabela `lifetracker_conversations` (armazena mensagens)
- [ ] Fun√ß√£o `build_user_context` (usa hist√≥rico)
- [ ] Views/queries que filtram por tipo de mensagem

**Integra√ß√µes**:
- [ ] UAZAPI docs (formato oficial atualizado?)
- [ ] Webhook signature validation (ainda v√°lida?)
- [ ] Rate limits/retries (afetados?)

**Docs**:
- [ ] `docs/integrations/UAZAPI.md` (atualizar formato)
- [ ] ADR sobre parsing de mensagens
- [ ] Debugging case deste bug

**Testes**:
- [ ] Unit test para parsing de bot√µes
- [ ] Integration test webhook ‚Üí database
- [ ] E2E test fluxo WhatsApp completo

**Resolu√ß√£o COMPLETA**:
1. ‚úÖ Fix parsing em `webhook-whatsapp-natural` (causa raiz)
2. ‚úÖ Validar `webhook-whatsapp-adapter` usa parsing correto
3. ‚úÖ Adicionar type guard `isButtonReply()` em `_shared/types`
4. ‚úÖ Criar unit test para todos formatos de bot√£o UAZAPI
5. ‚úÖ Atualizar `docs/integrations/UAZAPI.md` com formato novo
6. ‚úÖ Documentar em debugging case
7. ‚úÖ Verificar se outras webhooks t√™m parsing similar

**Checklist Resolu√ß√£o em Teia** (OBRIGAT√ìRIO):

**Mapeamento**:
- [ ] Listei TODOS arquivos conectados (import/export)?
- [ ] Identifiquei TODAS fun√ß√µes que chamam/s√£o chamadas?
- [ ] Mapeei TODAS tabelas/queries relacionadas?
- [ ] Encontrei TODOS componentes que consomem dados?
- [ ] Busquei TODA documenta√ß√£o relacionada?

**An√°lise**:
- [ ] Avaliei impacto da mudan√ßa em CADA conex√£o?
- [ ] Busquei padr√µes similares no codebase?
- [ ] Validei se outros lugares t√™m mesmo problema?
- [ ] Identifiquei testes faltantes?

**Resolu√ß√£o**:
- [ ] Corrigi causa raiz (RCA)?
- [ ] Corrigi padr√µes similares identificados?
- [ ] Atualizei TODA documenta√ß√£o relacionada?
- [ ] Adicionei testes para TODA teia mapeada?
- [ ] Validei n√£o introduzi regress√µes?

**Ferramentas para Mapeamento**:

```bash
# 1. Buscar imports/exports
grep -r "import.*from.*arquivo" src/
grep -r "export.*fun√ß√£o" src/

# 2. Buscar chamadas de fun√ß√£o
grep -r "nomeFun√ß√£o(" src/

# 3. Buscar refer√™ncias em DB
grep -r "lifetracker_table" supabase/

# 4. Buscar em documenta√ß√£o
grep -r "termo" docs/

# 5. Git history (casos passados)
git log --all --grep="keyword"
```

**Benef√≠cios**:
- ‚úÖ Solu√ß√£o COMPLETA (n√£o pontual)
- ‚úÖ Previne m√∫ltiplos bugs relacionados
- ‚úÖ Mant√©m consist√™ncia no codebase
- ‚úÖ Documenta√ß√£o sincronizada
- ‚úÖ Testes abrangentes

**Anti-Patterns**:
- ‚ùå Corrigir apenas arquivo do erro (m√≠ope)
- ‚ùå Ignorar padr√µes similares (retrabalho)
- ‚ùå Esquecer documenta√ß√£o (conhecimento perdido)
- ‚ùå N√£o adicionar testes (regress√£o futura)

**Regra de Ouro**: "Uma corre√ß√£o superficial √© um bug em potencial. Uma corre√ß√£o em teia √© uma solu√ß√£o definitiva."

**Ver**:
- Regra #4: RCA (identifica causa raiz)
- Regra #7: Preven√ß√£o de Regress√£o (valida mudan√ßas)
- Regra #9: Pareto 80/20 (foca no core da teia)

---

### üö® 5. ADVOGADO DO DIABO (Planning Validation)

**OBRIGAT√ìRIO** ao sugerir solu√ß√£o, criar plano, modificar/remover c√≥digo existente, ou remover docs.

**10 Perguntas cr√≠ticas**:

**Suposi√ß√µes**:
1. E se oposto for verdade?
2. O que N√ÉO estamos vendo?
3. Sintoma de algo maior?

**Fontes** ‚≠ê:
4. Quais s√£o suas fontes? (listar TODAS)
5. Pesquisou lugares certos? (gaps?)
6. Fontes atualizadas? (vers√µes?)

**Abordagem**:
7. Problema CERTO? (Reframing validado?)
8. O que pode dar errado? (pre-mortem)
9. Como validar antes? (POC/MVP?)

**Resultado**: ‚úÖ APROVADO | ‚ö†Ô∏è AJUSTAR | ‚ùå REJEITAR

---

### üö® 6. NUNCA CALCULAR ROI OU TEMPO DE EXECU√á√ÉO

**CR√çTICO**: Projeto √© desenvolvido por IA, n√£o humanos.

**PROIBIDO calcular**:
- ‚ùå ROI (Return on Investment)
- ‚ùå Tempo de execu√ß√£o de tarefas/projetos
- ‚ùå Estimativas de "horas economizadas"
- ‚ùå Compara√ß√µes de "Xmin vs Ymin"

**Por qu√™**:
- IA executa tarefas em paralelo (n√£o linear)
- Tempo varia muito por contexto/complexidade
- ROI n√£o se aplica (sem custo humano)
- Gasta tokens e polui relat√≥rios

**Permitido**:
- ‚úÖ Evid√™ncias concretas (c√≥digo, logs, dados)
- ‚úÖ Compara√ß√µes qualitativas ("mais r√°pido", "mais eficiente")
- ‚úÖ Dados externos validados (benchmarks, docs oficiais)

**Regra**: NEVER guess or assume. Use dados concretos ou n√£o mencione.

---

### üö® 7. PREVEN√á√ÉO DE REGRESS√ÉO

**NUNCA modificar c√≥digo funcionando** sem:
1. BUG COMPROVADO (screenshot/log)
2. REQUISITO EXPL√çCITO do usu√°rio
3. PROBLEMA REAL medido

**C√≥digo funcionando √© SAGRADO**.

**Checklist pr√©-modifica√ß√£o**:
- [ ] Motivo expl√≠cito documentado
- [ ] Snapshot ANTES capturado
- [ ] Branch separada criada
- [ ] Valida√ß√£o manual completa
- [ ] Snapshot DEPOIS vs ANTES comparado
- [ ] Teste automatizado criado

**Regra #5**: "No Bug Fix Without Test"

**Deploy incremental**:
1. Deploy 1¬™ mudan√ßa ‚Üí Validar 5-10min
2. Deploy pr√≥xima ‚Üí SE FALHAR: rollback
3. Repetir

**Benef√≠cio**: Valida√ß√£o incremental previne debugging massivo

---

### üö® 8. SOURCE OF TRUTH VALIDATION (Database)

**Problema**: Arquivos podem ficar defasados vs DB real.

**Source of Truth**: DB real > migrations > types.ts > docs

**SEMPRE validar ANTES de an√°lise**:
```bash
./scripts/validate-db-sync.sh      # Validar sincroniza√ß√£o
./scripts/regenerate-supabase-types.sh  # Se defasado
```

**Quando validar**:
- ‚úÖ ANTES de Workflow 2b (Technical Design)
- ‚úÖ ANTES de usar database-schema-validator agent
- ‚úÖ AP√ìS aplicar migrations/mudan√ßas schema

**Regra**: NUNCA confie em c√≥digo. SEMPRE query DB real.

---

### üö® 9. PRINC√çPIO PARETO 80/20 (FRAMEWORK OBRIGAT√ìRIO)

**CR√çTICO**: TODAS as solu√ß√µes devem seguir o framework completo na ORDEM exata:

**Framework Obrigat√≥rio** (executar sequencialmente):
1. **Reframing** ‚Üí Qual √© o problema REAL? (n√£o sintoma)
2. **RCA (5 Whys)** ‚Üí Qual √© a causa RAIZ? (sist√™mica, n√£o pontual)
3. **Advogado do Diabo** ‚Üí 10 perguntas cr√≠ticas de valida√ß√£o
4. **80/20 Pareto** ‚Üí Qual 20% entrega 80% do resultado?

**Aplica√ß√£o do 80/20**:

**Antes de QUALQUER solu√ß√£o, perguntar**:
- Qual 20% do c√≥digo/features entrega 80% do valor?
- Quais 20% dos problemas causam 80% das falhas?
- Qual solu√ß√£o M√çNIMA resolve o core issue?

**Identificar Bloat (os 80% desnecess√°rios)**:
- C√≥digo over-engineered (premature optimization)
- Features nice-to-have vs must-have
- Complexidade sem ROI comprovado
- Padr√µes excessivos para problema simples

**Prioriza√ß√£o Radical**:
1. Core functionality FIRST (20% que entrega 80%)
2. Nice-to-have LATER (80% que entrega 20%)
3. NUNCA implementar os 80% antes dos 20%

**Exemplo Real (WhatsApp Conversational AI)**:

**BLOAT (80% c√≥digo, 20% valor)**:
- FSM com 15 estados (1,500 linhas)
- RAG system (300 linhas)
- Intent detection (200 linhas)
- RAPPORT/personality (250 linhas)
- Streaming SSE (150 linhas)

**CORE (20% c√≥digo, 80% valor)**:
- Load last 10 messages (10 linhas)
- Call Gemini API (15 linhas)
- Save user + assistant messages (20 linhas)
- Send to WhatsApp (10 linhas)
- Total: ~55 linhas vs 2,400 linhas = 98% redu√ß√£o

**Checklist Valida√ß√£o 80/20**:
- [ ] Framework completo executado? (Reframing ‚Üí RCA ‚Üí Advogado ‚Üí 80/20)
- [ ] Identifiquei os 20% cr√≠ticos?
- [ ] Identifiquei os 80% bloat?
- [ ] Solu√ß√£o M√çNIMA vi√°vel definida?
- [ ] Complexidade justificada por EVID√äNCIA (n√£o teoria)?
- [ ] Valida√ß√£o incremental planejada?

**Regra de Ouro**: "Simple is better than complex. Complex is better than complicated." - Zen of Python

**Anti-Patterns a Evitar**:
- ‚ùå "Vamos fazer completo desde o in√≠cio"
- ‚ùå "Precisamos cobrir todos edge cases agora"
- ‚ùå "Futuramente vai precisar, ent√£o j√° implemento"
- ‚ùå "√â best practice, ent√£o deve ter"

**Patterns Corretos**:
- ‚úÖ "Qual M√çNIMO funciona?"
- ‚úÖ "Posso validar com 10% do c√≥digo?"
- ‚úÖ "Edge case tem evid√™ncia de ocorrer?"
- ‚úÖ "Best practice aplica a ESTE contexto?"

**Quando N√ÉO aplicar 80/20**:
- Seguran√ßa (RLS, auth, valida√ß√£o) - 100% obrigat√≥rio
- Compliance (LGPD, GDPR) - 100% obrigat√≥rio
- Data integrity - 100% obrigat√≥rio

**Documenta√ß√£o 80/20**:
- ADR para decis√µes de remover bloat
- Debugging Case se over-engineering causou bug
- Meta-Learning para prevenir recorr√™ncia

---

### üö® 10. ANTI-OVER-ENGINEERING (YAGNI + KISS)

**CR√çTICO**: SEMPRE validar se solu√ß√£o n√£o √© over-engineered ANTES de implementar.

**Princ√≠pios**:
1. **YAGNI** (You Aren't Gonna Need It) - N√£o implemente "para o futuro"
2. **KISS** (Keep It Simple, Stupid) - Solu√ß√£o mais simples SEMPRE vence
3. **Pareto 80/20** - 20% do c√≥digo entrega 80% do valor

**Checklist Anti-Over-Engineering (OBRIGAT√ìRIO)**:
- [ ] Esta solu√ß√£o resolve problema REAL (n√£o hipot√©tico)?
- [ ] Existe solu√ß√£o mais SIMPLES que funciona?
- [ ] Esta complexidade tem EVID√äNCIA de ser necess√°ria?
- [ ] Posso validar com 10% do c√≥digo proposto?
- [ ] Se remover isso, sistema QUEBRA ou apenas perde nice-to-have?

**Red Flags** (sinais de over-engineering):
- "Futuramente vai precisar..."
- "√â best practice, ent√£o deve ter..."
- "Vamos fazer completo desde o in√≠cio..."
- Mais de 3 camadas de abstra√ß√£o
- Padr√£o complexo para problema simples

**Exemplo Real (Sentry MCP)**:
- **Prometia**: Debug autom√°tico via MCP
- **Realidade**: Curl + API Sentry faz o mesmo
- **Overhead**: Configura√ß√£o, manuten√ß√£o, documenta√ß√£o
- **ROI**: Negativo (mais trabalho que benef√≠cio)
- **Decis√£o**: REMOVER (over-engineering)

**Quando N√ÉO simplificar**:
- Seguran√ßa (RLS, auth, crypto)
- Compliance (LGPD, GDPR)
- Data integrity (transa√ß√µes, valida√ß√µes)

**Documenta√ß√£o**:
- ADR 010: Anti-Over-Engineering Framework

---

### üö® 11. EVID√äNCIAS OBRIGAT√ìRIAS (CR√çTICO)

**REGRA ABSOLUTA**: TODA orienta√ß√£o, sugest√£o, solu√ß√£o ou an√°lise DEVE ser baseada em evid√™ncias concretas.

**NUNCA basear em**:
- ‚ùå Intui√ß√£o ("acho que...", "provavelmente...")
- ‚ùå Suposi√ß√µes fict√≠cias ("pode ser que...", "talvez...")
- ‚ùå Teoria n√£o validada ("geralmente √©...", "costuma...")
- ‚ùå "Best practices" sem fonte espec√≠fica
- ‚ùå Feeling, achismo, paranoia

**SEMPRE basear em**:
- ‚úÖ **Dados reais do projeto** (logs, m√©tricas, testes, git history)
- ‚úÖ **Documenta√ß√£o oficial RECENTE** (√∫ltimos 2 anos, vers√£o atual)
- ‚úÖ **Casos passados documentados** (docs/debugging-cases/, ADRs)
- ‚úÖ **Pesquisa web validada** (m√≠nimo 3 fontes confi√°veis, 2023+)
- ‚úÖ **C√≥digo fonte do projeto** (an√°lise direta, n√£o suposi√ß√£o)

### Checklist Valida√ß√£o de Evid√™ncias (OBRIGAT√ìRIO)

Para CADA orienta√ß√£o/sugest√£o, documentar:

**1. Tipo de Evid√™ncia**
- [ ] **Dados Projeto**: [m√©trica/log/teste espec√≠fico + valor]
- [ ] **Docs Oficiais**: [URL + se√ß√£o + vers√£o + data]
- [ ] **Caso Passado**: [docs/debugging-cases/XXX.md ou ADR/XXX]
- [ ] **Pesquisa Web**: [3+ URLs + snippets relevantes + datas]
- [ ] **C√≥digo Fonte**: [arquivo:linha + an√°lise direta]

**2. Atualidade**
- [ ] **Documenta√ß√£o √© RECENTE**? (< 2 anos, vers√£o compat√≠vel)
- [ ] **Pesquisa √© ATUAL**? (2023+, tecnologia ainda relevante)
- [ ] **Caso passado √© APLIC√ÅVEL**? (stack similar, contexto matching)

**3. Confiabilidade da Fonte**
- [ ] **Fonte prim√°ria**? (docs oficial, RFC, c√≥digo fonte)
  - vs ‚ùå Fonte secund√°ria (blog, tutorial, opini√£o)
- [ ] **Autor confi√°vel**? (mantainer, empresa oficial, expert reconhecido)
- [ ] **M√∫ltiplas fontes confirmam**? (m√≠nimo 3 fontes independentes)

### Ferramentas Obrigat√≥rias para Valida√ß√£o

**1. Pesquisa Web** (MCP firecrawl):
```bash
firecrawl_search({
  query: "topic official docs 2025",  # Sempre incluir ano
  limit: 5,
  sources: ["web"]
})
```

**2. Documenta√ß√£o Oficial** (MCP context7):
```bash
context7_get_library_docs({
  libraryID: "/org/project",  # Resolver ID antes
  topic: "specific feature",
  tokens: 3000
})
```

**3. An√°lise C√≥digo Projeto**:
```bash
# Grep para dados reais
grep -r "pattern" src/
# Git history para casos passados
git log --grep="keyword" --since="2024-01-01"
```

**4. Dados Mensur√°veis**:
```bash
# Logs, m√©tricas, testes
cat logs/production.log | grep "ERROR"
npm test -- --coverage
```

### Exemplo Aplicado

**‚ùå SEM EVID√äNCIAS** (PROIBIDO):
```
Sugest√£o: Usar Redis para cache
Motivo: "Redis √© best practice para performance"
```

**‚úÖ COM EVID√äNCIAS** (CORRETO):
```
Sugest√£o: React Query cache (staleTime: 5min)
Evid√™ncias:
1. Dados projeto: Query atual 1.2s (medido: src/hooks/useDashboardData.ts:15)
2. Docs oficial: https://tanstack.com/query/latest/docs/guides/caching (2024-11-01)
3. Caso passado: docs/debugging-cases/001-slow-dashboard.md (stack id√™ntica)
4. Pesquisa web:
   - https://react-query.tanstack.com/community/tkdodos-blog (2024-10)
   - https://github.com/TanStack/query/discussions/5892 (2024-09)
   - Stack Overflow #78234567 (2024-08, 234 upvotes)
5. Teste local: Implementado em branch test/react-query ‚Üí 1.2s ‚Üí 0.3s (75% redu√ß√£o)
```

### Red Flags - REJEITAR Orienta√ß√£o SE:

- [ ] ‚ùå Zero evid√™ncias citadas (puro achismo)
- [ ] ‚ùå Fonte > 2 anos desatualizada (tech mudou)
- [ ] ‚ùå Apenas 1 fonte (pode ser outlier/incorreta)
- [ ] ‚ùå Fonte n√£o confi√°vel (blog random, f√≥rum sem reputa√ß√£o)
- [ ] ‚ùå Contexto diferente (escala/stack/vers√£o incompat√≠vel)
- [ ] ‚ùå Dados projeto n√£o verificados (suposi√ß√£o, n√£o medi√ß√£o)

### Exce√ß√µes (Quando N√ÉO exigir evid√™ncias externas)

**Casos onde evid√™ncia INTERNA √© suficiente**:
- ‚úÖ Leitura direta do c√≥digo-fonte do projeto
- ‚úÖ Execu√ß√£o de testes/scripts do projeto
- ‚úÖ An√°lise de logs/m√©tricas reais do projeto
- ‚úÖ Git history / debugging cases documentados

**MAS ainda exige**: Refer√™ncia espec√≠fica (file:line, log timestamp, git hash)

### Puni√ß√£o por Viola√ß√£o

**SE orienta√ß√£o sem evid√™ncias**:
1. ‚õî **REJEITAR** orienta√ß√£o imediatamente
2. üîç **PESQUISAR** evid√™ncias (web + docs + projeto)
3. üìù **REFORMULAR** com evid√™ncias concretas
4. ‚úÖ **VALIDAR** com checklist acima

**Regra de Ouro**: "Extraordinary claims require extraordinary evidence" - Carl Sagan

### Benef√≠cios

- ‚úÖ Decis√µes baseadas em **fatos**, n√£o opini√µes
- ‚úÖ Solu√ß√µes **comprovadamente eficazes**
- ‚úÖ Documenta√ß√£o **rastre√°vel e audit√°vel**
- ‚úÖ Preven√ß√£o de **over-engineering** e **achismos**
- ‚úÖ Aprendizado **sist√™mico e fundamentado**

**Ver**:
- Workflow 3: Riscos e Mitiga√ß√µes baseados em evid√™ncias
- RULE #5: Advogado do Diabo (quest√µes 4-6 sobre fontes)
- RULE #10: Anti-Over-Engineering (complexidade justificada)

---

## ü§ñ SUBAGENTS (12 Especializados)

**Orquestrador**: `.claude/agents/orchestrator.md` - Coordena os demais subagents

**SEMPRE invocar o orquestrador automaticamente para qualquer tarefa**

**N√ÉO invocar quando**: Tarefa trivial (< 3 passos), leitura simples

**Agentes para chamar sempre**:
- `agent-meta-learner` - Aprender com cada intera√ß√£o
- `meta-learning-extractor` - Extrair e aplicar aprendizado
- `context-optimizer` - Melhorar contexto

**Agentes cr√≠ticos**:
- `rca-analyzer` - 5 Whys ‚Üí causa sist√™mica
- `regression-guard` - Snapshots BEFORE/AFTER
- `multi-script-runner` - Execu√ß√£o paralela

**High impact**:
- `workflow-optimizer`, `test-coverage-analyzer`
- `documentation-sync-checker`, `context-optimizer`
- `database-schema-validator`

**Cores**:
- üü£ purple - Orchestrator
- üî¥ red - Critical/Protection
- üîµ blue - Learning
- üü¢ green - Performance
- üü† orange - Validation

Ver: `.claude/agents/README.md`, `docs/SUBAGENTS.md`

---

## üîå MCPs INTEGRADOS (5 Servers)

**Model Context Protocol Servers** dispon√≠veis para capacidades especializadas:

| MCP | Tipo | O que faz | Quando usar |
|-----|------|-----------|-------------|
| **context7** | HTTP | Docs atualizadas de bibliotecas | Implementar com libs externas |
| **playwright** | stdio | Automa√ß√£o browser + testes E2E | Testes UI/UX, debugging frontend |
| **firecrawl-mcp** | stdio | Web scraping (search/crawl/map) | Pesquisa mercado, benchmarking |
| **gemini-cli** | stdio | Gemini AI CLI (sandbox/changeMode) | An√°lise complexa, valida√ß√£o c√≥digo |
| **supabase_lifetracker** | stdio | Gerenciamento Supabase (SQL, migrations, Edge Functions) | Debugging DB, an√°lise produ√ß√£o, deploy functions |

**Uso por Workflow**:
- **Workflow 2a** (Solutions): firecrawl search + context7 + gemini brainstorm
- **Workflow 2b** (Technical Design): context7 (validar APIs)
- **Workflow 5a** (Implementation): gemini sandbox + context7 (resolver doubts)
- **Workflow 5b** (Refactoring & RCA): supabase_lifetracker (EXPLAIN ANALYZE queries)
- **Workflow 6a** (User Validation): playwright (testes E2E)
- **Workflow 13b** (RCA & Metrics): gemini (RCA profundo) + firecrawl (pesquisa) + supabase_lifetracker (dados produ√ß√£o)

**Configura√ß√£o Supabase MCP**:
- Arquivo `.mcp.json` (gitignored - n√£o commitar token!)
- Personal Access Token: https://supabase.com/dashboard/account/tokens
- Ferramentas: execute_sql, apply_migration, deploy_edge_function

**Documenta√ß√£o Completa**: `docs/integrations/MCP.md`

---

## üìã DOCUMENTA√á√ÉO OBRIGAT√ìRIA

**SEMPRE consultar ANTES de a√ß√£o**:
1. `docs/PLAN.md` - Roadmap estrat√©gico
2. `docs/TASK.md` - Status tarefas
3. `docs/pesquisa-de-mercado/` - Fundamentos
4. `docs/adr/` - Decis√µes arquiteturais
5. `docs/INDEX.md` - √çndice de documentos
6. `README.md` - Documenta√ß√£o do projeto

**SEMPRE atualizar DEPOIS**:
1. `docs/TASK.md` - Marcar completadas
2. `docs/PLAN.md` - Se mudan√ßa estrat√©gica
3. `docs/adr/` - Se decis√£o arquitetural
4. `docs/INDEX.md` - Se novo documento
5. `README.md` - Se mudan√ßa significativa

**Regra**: NUNCA iniciar sem ler PLAN.md + TASK.md!

---

## üéØ CORE CONCEPTS

### 8 √Åreas da Vida (FIXAS)

1. Sa√∫de (Health) - ID: 1
2. Carreira (Career) - ID: 2
3. Relacionamentos (Relationships) - ID: 3
4. Finan√ßas (Finance) - ID: 4
5. Desenvolvimento Pessoal - ID: 5
6. Lazer (Leisure) - ID: 6
7. Espiritualidade - ID: 7
8. Ambiente (Environment) - ID: 8

**‚ö†Ô∏è NUNCA adicionar/remover √°reas. IDs 1-8 imut√°veis.**

### Features Core

1. **Assessments Din√¢micos**: IA adaptativa, Wheel of Life
2. **Habit Tracking**: Streak counting, calend√°rio, gamifica√ß√£o
3. **AI Coach**: Chat contextual, insights, daily messages
4. **Goals**: SMART goals, milestones, progress
5. **Dashboard**: M√©tricas agregadas, charts (Recharts)

---

## üóÑÔ∏è DATABASE

**Prefixo obrigat√≥rio**: `lifetracker_`

**RLS obrigat√≥rio**:
```sql
ALTER TABLE lifetracker_table ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users view own" ON lifetracker_table FOR SELECT USING (auth.uid() = user_id);
```

**Ver**: `docs/ARCHITECTURE.md`, `supabase/migrations/` (valida√ß√£o em Regra üö® 8)

---

## üìê CONVEN√á√ïES

**Naming**:
- Vari√°veis/fun√ß√µes: `camelCase` (ingl√™s)
- Componentes: `PascalCase`
- Database: `snake_case` + `lifetracker_`
- API: `kebab-case`

**Coment√°rios/Commits**: Portugu√™s + Conventional Commits

**8 √Åreas**: Sempre IDs 1-8 (n√£o strings), NUNCA CRUD

---

## üîÑ WORKFLOWS

**31 workflows ativos**: `.windsurf/workflows/`

**Regra**: SEMPRE seguir workflows. NUNCA pular etapas.

Ver: `docs/WORKFLOW_META_LEARNING.md`

---

## ‚è∞ CONTEXTO TEMPORAL

**Timezone**: America/Sao_Paulo (UTC-3)

**Regras**:
1. NUNCA hardcode anos/meses ‚Üí `new Date()`
2. Queries din√¢micas: `WHERE data >= CURRENT_DATE`
3. Logs com timezone

---

## üîí SEGURAN√áA

1. ZERO secrets hardcoded ‚Üí `.env`
2. RLS obrigat√≥rio
3. NUNCA logar dados sens√≠veis
4. Queries parametrizadas (SQL injection)
5. GDPR/LGPD compliance

---

## üöÄ PERFORMANCE

**Targets**:
- Dashboard: < 2s
- Coach Chat: < 5s
- Habit Logging: Instant√¢neo (optimistic)

**T√©cnicas**:
- React Query cache (5min staleTime)
- Lazy Loading (Wheel, Calendar)
- Optimistic Updates
- Memoiza√ß√£o (useMemo/useCallback)

---

## üí∞ AI COSTS

- **Gemini 2.5 Flash**: $0.30/1M input, $2.50/1M output
- **Context Caching**: 75-90% economia
- **Rate Limits**: 30 msgs/h (coach), 5 assessments/dia
- **Token Limits**: coach (500), assessment (300)

---

## üß™ TESTES

**Priorit√°rios**:
1. RLS Policies (isolamento usu√°rios)
2. AI Responses (Zod validation)
3. Habit Streaks (l√≥gica gamifica√ß√£o)
4. Assessment Scores (8 √°reas)

**TDD obrigat√≥rio**: L√≥gica neg√≥cio

**Regra**: "No Bug Fix Without Test"

---

## üîÑ FLUXO DESENVOLVIMENTO

```bash
# 1. Branch
git checkout -b feat/nome

# 2. Develop + TDD
npm run dev

# 3. Quality Gates
./scripts/run-tests.sh
./scripts/code-review.sh
./scripts/run-security-tests.sh

# 4. Valida√ß√£o Manual (OBRIGAT√ìRIA)
# - Screenshot ANTES
# - Testar fluxo
# - Screenshot DEPOIS
# - Comparar ANTES vs DEPOIS

# 5. Commit
git commit -m "feat: descri√ß√£o"

# 6. Merge (ap√≥s valida√ß√£o)
```

---

## üöÄ DEPLOYMENT

**VPS Docker Swarm**: 31.97.22.151

**Deploy**: `./scripts/deploy-vps.sh production`

**Best Practices**:
- Multi-stage builds (1GB ‚Üí 45MB)
- Health checks: `127.0.0.1` (Alpine, N√ÉO localhost)
- Traefik label: `traefik.docker.network=network_public`
- .env em BUILD TIME (Vite)

**Workflow**:
1. Feature local (Workflows 1-9)
2. Merge main
3. **Checklist pr√©-deploy** (ver Preven√ß√£o Regress√£o)
4. Deploy VPS
5. Smoke tests + health checks
6. Monitor 10-15min
7. Rollback se necess√°rio

**Troubleshooting**:
- Container n√£o inicia: `ssh root@IP "docker service logs -f lifetracker_app"`
- Traefik: Verificar label `docker.network`
- Build: Verificar .env dispon√≠vel

**Meta-Learnings**:
- ML-1: .dockerignore bloqueando .env
- ML-2: traefik.docker.network CR√çTICO
- ML-3: Alpine 127.0.0.1 vs localhost
- ML-4: 5 agentes = 4x r√°pido
- ML-5: Multi-stage = 95% redu√ß√£o

Ver: `docs/ops/`, ADR 003

---

## üìö DOCS COMPLEMENTARES

**Detalhes completos**:
- `docs/FEATURES.md` - Features detalhadas
- `docs/ARCHITECTURE.md` - Arquitetura completa
- `docs/TROUBLESHOOTING.md` - Debugging
- `docs/USER_FLOWS.md` - 4 fluxos cr√≠ticos

---

**Vers√£o**: 2.11.0 (2025-11-09)
**Projeto**: Life Track Growth

**Changelog v2.11.0**:
- ‚úÖ **Workflow 7a/7b Quality Gates Completo**: 100% security approved
  - 3 testes Pareto 80/20 validados (get_user_progress, log_habit_entry, RAG 768 dims)
  - 6 bugs corrigidos iterativamente (V1‚ÜíV10)
  - Gap sist√™mico identificado: Scripts security n√£o filtram escopo (RCA completo)
  - Meta-Learning: Flag `--scope` para scripts (reduz 96% falsos positivos)
- üéØ **Novo Padr√£o: Fuzzy Matching Multi-Strategy**
  - 4 estrat√©gias: exact (100), substring (80), root (60), partial (40)
  - Success rate: 91% em testes morfol√≥gicos ("treino" ‚Üí "Treinar")
  - Aplic√°vel: NLP, search, matching user input vs database
- ‚è∞ **Edge Functions Timezone Pattern**
  - UTC (server) ‚Üí America/Sao_Paulo (user) conversion obrigat√≥rio
  - Previne bugs off-by-one em datas
  - Implementa√ß√£o: `new Date(now.toLocaleString('en-US', { timeZone: 'America/Sao_Paulo' }))`
- üìã **TASK.md Task 9.3 adicionada**: Workflow 7a/7b documentado
- üìö **INDEX.md v2.1**: Quality Gates milestone registrado

**Changelog v2.10.0**:
- ‚úÖ **NOVA REGRA 4B**: Resolu√ß√£o em Teia (Web Resolution)
  - Metodologia completa para mapear e resolver TODA teia de problemas conectados
  - An√°lise 360¬∞: Frontend + Backend + Database + Integra√ß√µes + Docs + Testes
  - Checklist obrigat√≥rio de mapeamento, an√°lise e resolu√ß√£o
  - Ferramentas de mapeamento (grep patterns) inclu√≠das
  - Exemplo pr√°tico (Bug Parsing WhatsApp) documentado
- üìù Atualizado √≠ndice de regras (12 regras cr√≠ticas)
- üîó Cross-references atualizadas (Regra 3, 4, 7, 9)
- üìä Benef√≠cios documentados: Solu√ß√£o completa, preven√ß√£o m√∫ltiplos bugs, consist√™ncia

**Changelog v2.9.0** (2025-11-08):
- Otimizado para < 40k chars (Anthropic guidelines)
- Removido conte√∫do redundante/detalhado (movido para docs/)
- Mantidas TODAS regras cr√≠ticas (RCA, Regress√£o, Agentes, etc)
- Formato mais escane√°vel (bullets, exemplos concisos)
- Priorizado: Comandos essenciais, padr√µes arquiteturais, regras absolutas
